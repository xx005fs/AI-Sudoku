# AI-Sudoku
An experiment on solving a board of Sudoku using AI
# Introduction
In 2017, I joined a club that talked about the basics of AI, as well as attempted to make my own AI project. I found it incredibly interesting, however, at the time my knowledge in math and computer science wasn't enough to comprehend the lectures taught there. As I go through more curriculum in the course of a year, I have learned more about the math behind AI and now I could comprehend more. Just a month before summer break of 2019, I learned a bit more about Tensorflow and Python in general by myself, by watching their tutorials, running their demo files such as the image recognition networks using MNIST. Then I decided to pick up an old project I made in the past, which was the Sudoku solver, and I thought that it was something that hasn't been implemented before, and attempted to make it work.
# How it works (and why it sort of doesn't work)
The new AI solver uses the Monte Carlo Tree Search algorithm to find the possible solutions of the Sudoku board. Instead of the previous solver which used hard coded logic and also an iterative method that exhausts possible combinations of the board to solve it, this solver uses the MCTS, which essentially computes the next step of the board by comparing the probability of each individual block, then choosing the one with the highest probability among the other ones. The MCTS search is similar to what a human would do while playing a Sudoku, by first determining which blocks are the most optimal for trying a certain number in it, then guessing the rest based on the rule of the game. When one guess from a certain step fails, it back-tracks to find another possible value and fill it in. Similarly, the previous solver instead used a hard-coded method of the strategy, which means that it won't be as flexible as the MCTS algorithm and neither would it be as easy to implement. The purely MCTS algorithm doesn't guarantee to solve a certain board, however, its success rate is relatively high, but the time it takes to solve a board is significantly slower than the iterative method used in the previous version of the solver (might be due to overhead of Python compared to that of Java). (More explanations in the comments of the codes)
However, the MCTS algorithm along wasn't enough to satisfy my interest in AI, hence I decided to add some AI elements into it by taking the idea from AlphaGO and other similar methods that uses self-learning. Using AI, the computer can find the pattern between say which values should be tried first in the MCTS algorithm to make it either solve it faster or be able to solve it. The AI gives a weigh to the probabilities that MCTS would use to try, and thus giving the MCTS algorithm a supposed advantage to solve it compared to solving it using MCTS alone. 
Despite the attempts, the network eventually didn't converge that well, only going from a loss of 7.8 or so down to the mid 5.5s, which means that if I put in a random Sudoku board through the network, it would most likely be unable to solve it and might even be worse than using the original MCTS algorithm. I have asked other people working in the field of AI for this problem, and I got more insights about how the learning rate could be too low to affect the result or whether I should use Conv2D or Conv3D for the CNN. What I have learned is that usually Signal processing such as voice recognition uses Conv1D, image processings generally uses Conv2D, and video processing generally uses Conv3D. As my knowledge isn't deep enough about AI, I decided to stick with Conv2D even though it doesn't work that well, as a Sudoku board is similar to any board game, which from my experience have always used Conv2D instead of Conv3D. 

# Performance
Compared to the previous solver written in Java, the pure MCTS solver is significantly slower, by up to 20 times in some cases. Using AI however, the model would be even slower than the pure MCTS method as it requires training that might not even led to a converged model. Though part of the 20x speed up can be contributed to Python having higher execution overhead than Java, and that's an issue that can't be resolved in any meaningful way.
# My thoughts on it
I think the reason why it fails is that Sudoku isn't just a simple board game. Since most board games requires two players, and each time there are many many ways to win, that allows a large margin of error for the neural network to make decisions, and it will have many more possible outcomes than a Sudoku game would. Also, despite having a fixed rule, board games are significantly more flexible as the rules aren't very strict on the requirements for saying on which tile you have to put an exact value or object like Sudoku would. This means that it makes sense that Sudoku will be incredibly hard to converge since the AI would have an extremely tough time finding a viable pattern that would work for every single board. Since the way AI solves Sudoku is extremely similar to how a human would solve it, there's no way to guarantee a human to use the same rule every single time to solve every single board of Sudoku. Overall, the very limited amount of outcomes of a Sudoku board (mostly only 1 possible solution) is what led to this network being unable to converge, since it is very difficult to find a universal pattern between something that have such limited solution and requires great accuracy within the model. 
# Compares to other methods of solving Sudoku using AI
There's another project on GitHub that solves Sudoku board using a similar approach than image processing would, that is taking a huge amount of data of Sudoku boards and uses CNN to figure out the patterns between them. (source https://github.com/Kyubyong/sudoku) However, this method doesn't really work that well either, despite the extremely fast converge rate at the beginning of the game (from being extremely inaccurate at a loss of over 150 down to 1.6), it is still unable to solve most Sudoku boards. The conclusion I have drawn from either attempts is that I personally think that Sudoku is a game that is so strict on rules and an AI is way too flexible for it, and traditional computing methods would have a great advantage over AI both in terms of speed and accuracy.
# My thoughts on Python vs Java
